import React, { useState, useEffect } from "react";
import { v4 as uuidv4 } from "uuid";

type Point = { x: number; y: number };

const convertY = (y: number, height: number): number => {
  return height - y;
};

// TODO these ought to be consolidated in some fashion
const branchWidth = (size: number, currentDepth: number, base: boolean) => {
  // TODO rename
  const trapezoidalAdjustment = base ? 5 : -5;
  return size / 5 - currentDepth * 5 + trapezoidalAdjustment;
};

// TODO probably need a funciton that goes from a cartesian Point or Array<Point>
//      to an SVG ready string

const Line = (props: {
  point1: Point;
  point2: Point;
  containerHeight: number;
  currentDepth: number;
  size: number;
}) => {
  const { point1, point2, containerHeight, currentDepth, size } = props;
  const angleVal = angle(point1, point2);
  //  const lengthVal = length(point1, point2);
  const lengthVal = 25;
  const trapezoidPoints = [
    newPoint(point1, angleVal + Math.PI / 2, lengthVal),
    newPoint(point1, angleVal - Math.PI / 2, lengthVal),
    newPoint(point2, angleVal - Math.PI / 2, lengthVal),
    newPoint(point2, angleVal + Math.PI / 2, lengthVal),
  ];
  //  const trapezoidPoints: Point[] = [point1, point2]
  //    .map((point) => {
  //      return [angleVal + Math.PI / 2, angleVal - Math.PI / 2].map((angle) => {
  //        return newPoint(point, angle, lengthVal);
  //      });
  //    })
  //    .flat();
  const trapezoidPointsString = trapezoidPoints
    .map((p: Point) => {
      return p.x + "," + convertY(p.y, containerHeight);
    })
    .join(" ");

  const width = size / 5 - currentDepth * 5;
  return (
    <polygon
      points={trapezoidPointsString}
      fill="var(--fg-color-1)"
      stroke="var(--fg-color-2)"
    />
  );
  //  return (
  //    <line
  //      x1={point1.x}
  //      x2={point2.x}
  //      y1={convertY(point1.y, containerHeight)}
  //      y2={convertY(point2.y, containerHeight)}
  //      style={{ stroke: "var(--fg-color-1)", strokeWidth: width }}
  //    ></line>
  //  );
};

type BranchConfig = {
  depth: number;
  size: number;
  rawDepth: number;
  // branchCount: number;
  //  trunkHeight: number;
  //  trunkWidth: number;
  //  angleSpread: number;
};

const getBranchConfig = (size: number): BranchConfig => {
  const rawDepth = size / 20;
  return {
    depth: Math.floor(rawDepth),
    rawDepth,
    size: size,
    // branchCount: Math.min(5, Math.floor(size / 30)),
    //    trunkHeight: size * 0.4,
    //    trunkWidth: size * 0.1,
    //    angleSpread: 30, // degrees of total angle to spread child branches
  };
};
const length = (point1: Point, point2: Point): number => {
  return Math.sqrt(
    Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2),
  );
};

const angle = (point1: Point, point2: Point): number => {
  return Math.atan2(point2.y - point1.y, point2.x - point1.x);
};

const newPoint = (
  originalPoint: Point,
  angle: number,
  length: number,
): Point => {
  return {
    x: originalPoint.x + length * Math.cos(angle),
    y: originalPoint.y + length * Math.sin(angle),
  };
};

const nextPoints = (
  point1: Point,
  point2: Point,
  // TODO unrelated but astro-ish refactor of redirect
  // TODO - consider sending the obj again, this is verbose...
  depth: BranchConfig["depth"],
  size: BranchConfig["size"],
  rawDepth: BranchConfig["rawDepth"],
  currentDepth: number,
): Array<Point> => {
  const angleVal = angle(point1, point2);
  const angleSpread = Math.PI / 6;
  const lengthValue = length(point1, point2);
  // TODO this is very grug; refactor
  const progressToNextDepth = rawDepth - depth;
  const lengthMultiplier = () => {
    if (currentDepth === depth - 2) {
      return 0.5 * progressToNextDepth;
    }
    return 0.5;
  };
  const newLength = lengthValue * lengthMultiplier();

  const result = [angleVal - angleSpread, angleVal, angleVal + angleSpread].map(
    (angle) => {
      return newPoint(point2, angle, newLength);
    },
  );
  return result;
};

const Branch = (props: {
  currentDepth: number;
  branchNumber: number;
  point1: Point;
  point2: Point;
  depth: BranchConfig["depth"];
  size: BranchConfig["size"];
  rawDepth: BranchConfig["rawDepth"];
  containerHeight: number;
}) => {
  const {
    currentDepth,
    branchNumber,
    point1,
    point2,
    depth,
    size,
    rawDepth,
    containerHeight,
  } = props;

  if (currentDepth >= depth) {
    const points = [
      [point1.x, point1.y],
      [point1.x, point1.y + 5],
      [point1.x + 5, point1.y + 5],
      [point1.x + 5, point1.y],
    ]
      .map((v) => [v[0], convertY(v[1], containerHeight)].join(","))
      .join(" ");
    return (
      <polygon
        points={points}
        fill="var(--fg-color-2)"
        stroke="var(--fg-color-2)"
      />
    );
  }

  const np = nextPoints(point1, point2, depth, size, rawDepth, currentDepth);

  const insetOriginPoint = (
    point1: Point,
    point2: Point,
    insetFactor = 0.05,
  ) => {
    // type Point = { x: number; y: number };
    const dx = point2.x - point1.x;
    const dy = point2.y - point1.y;

    return {
      x: point1.x - dx * insetFactor,
      y: point1.y - dy * insetFactor,
    };
  };

  return (
    <>
      <Line
        size={size}
        currentDepth={currentDepth}
        point1={insetOriginPoint(point1, point2)}
        point2={{ ...point2 }}
        containerHeight={containerHeight}
      />
      {np.map((nextPoint, index) => {
        return (
          <Branch
            key={`${currentDepth}-${branchNumber}-${index}`}
            point1={point2}
            point2={nextPoint}
            currentDepth={currentDepth + 1}
            branchNumber={index}
            depth={depth}
            size={size}
            rawDepth={rawDepth}
            containerHeight={containerHeight}
          />
        );
      })}
    </>
  );
};

// TODO break components out into own file

export const Tree = () => {
  const [size, setSize] = useState(100);
  const [config, setConfig] = useState(getBranchConfig(size));
  const [lengthUnit, setLengthUnit] = useState();
  const containerHeight = 500;
  const width = 500;
  //  const size = 100;
  //
  useEffect(() => {
    const v = getBranchConfig(size);
    setConfig(v);
  }, [size]);

  // TODO rename
  const myVal = (containerHeight: number, size: number) => {
    return (size * containerHeight) / 600;
  };

  //  const config = getBranchConfig(size);

  // TODO --> path?
  // TODO --> consider if React/ChangeEvent shoudl be imported a different way
  // TODO --> improve typing around set functions etc
  const handleSizeChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setSize(Number(e.target.value));
  };

  return (
    <div className="px-8 border border-fuchsia-500">
      <label>
        size
        <input
          style={{ marginLeft: "10px" }}
          id="size"
          type="number"
          min={20}
          max={120}
          value={size}
          onChange={handleSizeChange}
        />
      </label>
      <p>{size}</p>
      <svg
        width={width}
        height={containerHeight}
        xmlns="http://www.w3.org/2000/svg"
        style={{ backgroundColor: "var(--bg-color-2)" }}
      >
        <Branch
          currentDepth={0}
          key={uuidv4()}
          branchNumber={0}
          point1={{ x: width / 2, y: 0 }}
          point2={{ x: width / 2, y: myVal(size, containerHeight) * 2 }}
          depth={config.depth}
          size={config.size}
          rawDepth={config.rawDepth}
          containerHeight={containerHeight}
        />
        {/*
        <Branch
          currentDepth={0}
          key={uuidv4()}
          branchNumber={1}
          point1={{ x: width / 2, y: 50 }}
          point2={{
            x: width / 2 + myVal(size, containerHeight),
            y: myVal(size, containerHeight) * Math.sqrt(3) + 50,
          }}
          depth={config.depth}
          size={config.size}
          rawDepth={config.rawDepth}
          containerHeight={containerHeight}
        />
        <Branch
          currentDepth={0}
          key={uuidv4()}
          branchNumber={1}
          point1={{ x: width / 2, y: 50 }}
          point2={{
            x: width / 2 - myVal(size, containerHeight),
            y: myVal(size, containerHeight) * Math.sqrt(3) + 50,
          }}
          depth={config.depth}
          size={config.size}
          rawDepth={config.rawDepth}
          containerHeight={containerHeight}
        />
        */}
      </svg>
    </div>
  );
  // TODO ^^ containerHeight function of size
};
